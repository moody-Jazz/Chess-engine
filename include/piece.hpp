#pragma once

#include "bitboard.hpp"
#include "global.hpp"
#include <string>


static uint64_t index{}, moveBitmask{};
class Piece
{
    public:
    
    Piece() = default;
    Piece(const Piece& obj);
    BitBoard pieceBitboards[12];           // Stores bitboard of each piece set for example for all the white pawns
    bool check[2];                         // Stores the boolean to indicate wheather king is in check for both white and black
    bool castle[2][2];                     // Stores the casteling state
    size_t kingPosition[2];                // Stores white and black king positions
    size_t enPassant;   
    uint64_t (Piece::*pseudoLegalMoveFuncs[6])(bool&, uint16_t&);                  
    
    // Utility Functions
    void initFunctionPointers();
    static uint64_t pawnAttackBitmaskInit(size_t side, size_t square);  // Used to populate pawnAttackBitmask array
    static uint64_t pawnPushBitmaskInit(size_t side, size_t square);    // Used to populate pawnPushBitmask array
    static uint64_t knightAttackBitmaskInit(size_t square);             // Used to populate knightAttackBitmask array
    static uint64_t kingAttackBitmaskInit(size_t square);               // Used to populate kingAttackBitmask array
    static uint64_t getBishopAttacks(size_t square, uint64_t block);    // Used to get a bitboard indicating all the possible Bishop moves
    static uint64_t getRookAttacks(size_t square, uint64_t block);      // Used to get a bitboard indicating all the possible Rook moves
    static uint64_t getQueenAttacks(size_t square, uint64_t block);     // Used to get a bitboard indicating all the possible Queen moves
    static void initRookAttacksWithoutBorder();                         // same as rook attack but any attack on border tile is not considered
    static void initBishopAttacksWithoutBorder();                       // same as bishop attack but any attack on border tile is not considered
    bool isKingSafe(bool white) const;                                  // Returns true or false based on king safety
    char getPieceType(size_t tile) const;                               // if theres a piece on tile it returns it char type else returns '0'
    uint64_t getPseudoLegalPawnMoves(bool& side, uint16_t& square);
    uint64_t getPseudoLegalKnightMoves(bool& side, uint16_t& square);
    uint64_t getPseudoLegalBishopMoves(bool& side, uint16_t& square);
    uint64_t getPseudoLegalRookMoves(bool& side, uint16_t& square);
    uint64_t getPseudoLegalQueenMoves(bool& side, uint16_t& square);
    uint64_t getPseudoLegalKingMoves(bool& side, uint16_t& square);
    uint64_t getLegalMoves(char type, uint16_t source);                   // Convert possible moves generated by getPseudoLegalMoves() into valid mvoes

    // Mutator Functions
    void initPieceBitboards();
    void setupInitialFlagsAndPositions();
    void updatePieceBitboards(char type, size_t source, size_t dest);       // updates given piece bitboard
    void updatePieceBitboards(size_t srcTile, size_t destTile);
    void updateCombinedBitboards();
    void promotePawn(uint16_t src, uint16_t dest, uint16_t promo);
    void updateUnsafeTiles();                                // update the unsafe tile bitboard for both players after each turn

private:
    uint64_t bitboards_[3];                 // Stores the bitboard for black pieces white pieces and all pieces
    uint64_t unsafeTiles_[2];               // Stores the bitboard indicating unsafe tiles for white and black
};